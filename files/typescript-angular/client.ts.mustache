import { HttpClient, inject } from '@angular/common';

class Client {
    private readonly httpClient = inject(httpClient);


}

export interface Configuration {
  foo: string;
}

export const newClient = (c: Configuration, f: Fetch = fetch) => {
  return {
    ...endpoints(c, f),
  }
}

{{ #types }}{{ > type }}{{ /types }}

type QueryParams = Record<
    string, 
    string | number | boolean | string[] | boolean[] | number[] | undefined | null
>;

const populatePathTemplate = (
  template: string,
  properties: Record<string, any>
): string => {
  for (const k of Object.keys(properties)) {
    template = template.replace(`{${k}}`, encodeURIComponent(properties[k]));
  }

  return template;
};

type RequestBuilder<T> = {
  withPath: (r: Record<string, string>) => RequestBuilder<T>;
  withQuery: (q: QueryParams) => RequestBuilder<T>;
  withConfig: (c?: Partial<RequestConfig>) => RequestBuilder<T>;
  withBody: (b: any) => RequestBuilder<T>;
  withResponseMap: (m: any) => RequestBuilder<T>;
  send: (c: Configuration, f: Fetch) => Promise<T>;
};
const request = <T>(
  method: string,
  routeTemplate: string
): RequestBuilder<T> => {
  let config: InternalRequestConfig = {
    url: BASE_PATH + routeTemplate,
    config: {
      method,
    },
  };
  let query: QueryParams | null = null;
  let known: number[] = [];

  const builder = {
    withPath,
    withQuery,
    withConfig,
    withBody,
    withResponseMap,
    send,
  };

  return builder;

  function withPath(r: Record<string, string>) {
    config.url = populatePathTemplate(config.url, r);
    return builder;
  }
  function withQuery(r: QueryParams) {
    query = r;
    return builder;
  }
  function withConfig(c?: Partial<RequestConfig>) {
    config.config = {
      ...config.config,
      ...c,
    };
    return builder;
  }
  function withBody(b: any) {
    config.config.body = JSON.stringify(b);

    return builder;
  }
  function withResponseMap(responses: number[]) {
    known = responses;
    return builder;
  }
  async function send<T>(c: Configuration, f: Fetch): Promise<T> {
    const u = url.parse(config.url, true);
    u.query = {
      ...u.query,
      ...(query as any),
    };

    const response = await f(url.format(u), {
        ...config.config
    });

    if (!known.includes(response.status)) {
        // Throw an error unless a default error is known
    }

    return await response.json();
  }
};

// Apis
const endpoints = (c: Configuration, f: Fetch) => ({
{{ #operations }}
{{ > comment }}
    {{name}}: ({{#body}}body: {{type}}, {{/body}}{{#parameters}}{{name}}{{#optional}}?{{/optional}}: {{type}}, {{/parameters}} config?: RequestConfig) => 
      request<{{#responseTypes}}{{.}}{{/responseTypes}}>('{{method}}', '{{path}}')
        {{#hasPath}}.withPath({ {{#parameters}}{{#inPath}}{{name}}, {{/inPath}}{{/parameters}} })
        {{/hasPath}}{{#body}}.withBody(body)
        {{/body}}{{#hasQuery}}.withQuery({ {{#parameters}}{{#inQuery}}{{name}}{{#default}}: {{name}} ?? {{default}}{{/default}}, {{/inQuery}}{{/parameters}} })
        {{/hasQuery}}.withConfig(config)
        .send(c, f),
  {{ /operations }}
{{ #apis }}{{ > comment}}{{ name }}: {
{{ #operations }}
{{ > comment }}
    {{name}}: ({{#body}}body: {{type}}, {{/body}}{{#parameters}}{{name}}{{#optional}}?{{/optional}}: {{type}}, {{/parameters}} config?: RequestConfig) => 
      request<{{#responseTypes}}{{.}}{{/responseTypes}}>('{{method}}', '{{path}}')
        {{#hasPath}}.withPath({ {{#parameters}}{{#inPath}}{{name}}, {{/inPath}}{{/parameters}} })
        {{/hasPath}}{{#body}}.withBody(body)
        {{/body}}{{#hasQuery}}.withQuery({ {{#parameters}}{{#inQuery}}{{name}}{{#default}}: {{name}} ?? {{default}}{{/default}}, {{/inQuery}}{{/parameters}} })
        {{/hasQuery}}.withConfig(config)
        .send(c, f),
  {{ /operations }}},
{{ /apis }}});